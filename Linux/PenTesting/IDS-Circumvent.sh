#! /bin/bash

## Time of script start
start=`date +%s`

## Create functions for output
ok_text(){
  # Show a green [  ok  ] if all is well
  echo -e "[  \033[0;32mOK\033[0m  ] "$1
}

info_text(){
  # Show a blue [ INFO ]
  echo -e "[ \033[0;34mINFO\033[0m ] "$1
}

error_text(){
  # Show a red [ FAIL ] if there is an issue
  echo -e "[ \033[0;31mFAIL\033[0m ] "$1
}

change_ip(){
  # use ifconfig to change the IP
  ifconfig $1 $2 netmask 255.255.255.0
  # Script dosnt work if this isnt here
  dhclient &> /dev/null
}

file_write(){
  # Write to a file ($1 is filename $2 is contents)
  echo $1 >> $2.txt
}

host_test(){
  ok_text "Testing host : "$1

  # Ping host and see if "errors" in output, 1 if yes, 0 of no
  #   (ping will wait 167ms before aborting scan, this means 3 hosts are scanned in 501ms
  #   evading the IDS as closly as possible)
  #
  #   Ping only sends one packet (-c 1) to see if host is up, grep looks for the
  #   word errors to see if there was an issue with the ping and WC-l counts
  #   how many lines grep returned
   check=$(ping -c 1 -i 0.167 $1 | grep errors | wc -l)

   # Wait for everything to finish
   wait

  # If the host is alive, add to targets file, if not add to available hosts file
   if [ $check -eq 0 ]
   then
     echo $1 >> active.txt
   else
    echo $1 >> available.txt
   fi
}

host_scan(){
  # Portscan and grep / wc to just return 1 or 0 if the port is open or closed
  portScan=$(nmap -p $1 $2 | grep open | wc -l)

  # If the port is open, tell me, do nothing if not
  if [ $portScan -eq 1 ]
  then
    # Show me the port ($1) and the host IP ($2) and dump it to a file
    ok_text "Port "$1" on host "$2" is open"
    echo "$2 : $1" >> "$fileName-output.txt"
  fi
}

# Clear the screen
clear

# Show introduction ASCII text
echo "### ######   #####      #####"
echo " #  #     # #     #    #     # # #####   ####  #    # #    # #    # ###### #    # #####"
echo " #  #     # #          #       # #    # #    # #    # ##  ## #    # #      ##   #   #"
echo " #  #     #  #####     #       # #    # #      #    # # ## # #    # #####  # #  #   #"
echo " #  #     #       #    #       # #####  #      #    # #    # #    # #      #  # #   #"
echo " #  #     # #     #    #     # # #   #  #    # #    # #    #  #  #  #      #   ##   #"
echo "### ######   #####      #####  # #    #  ####   ####  #    #   ##   ###### #    #   #"
echo ""
echo "By up837417"
echo ""

## Check if sudo is running (because of ping interval)
# This checks by looking for the users ID, root will always be 0
if [ "$EUID" -ne 0 ]
  # tell me there is a problem and stop the script
  then error_text "Please run as root"
  exit
fi

# Generate an array of all possible IP combinations
# this array just holds numbers, e.g. {1,2,3,5,6 ... 253,254}
Hosts=($(seq 1 254))

# Get the systems network adapter
# get the ccurrent adapters, filter for just the adapter names and use grep for
# the adapter in use
adapterR=$(ip -o link show | awk '{print $2,$9}' | grep UP)
# Clip of the link ststus and just keep the adapter (used for IP address change)
adapter=${adapterR%:*}
# Get the scripts base name
fileNameR=`basename $0`
# Get rid of the SH as this is used to generate the results filename
fileName=${fileNameR%.*}

# Get the system's IP address
IP=$(hostname -I)

## Concat this to the network prefix (Remove everything after the last .
## then put the . back)
address=${IP%.*}.

## Ports to test
ports=(21 22 23 53 79 80 123)

# Loop through all the hosts in the array
for host in ${Hosts[@]}; do
# Create the IP to test
# (Takes the network prefix from earlier and adds the number from the hosts array)
# e.g. address = 192.168.3. host = 1 so the hostIP = 192.168.3.1
  hostIP=$address$host

# Check to ensure the script is not scanning the host it is running on

if [ $hostIP != $IP ]
then
  # Test the host but allow for multiple processes
  host_test $hostIP &
  # Delay for 0.167 seconds allowingf for 3 hosts to be scanned in 501ms
  sleep 0.167
 fi
done
# Wait for all the processes to finish
wait

## Create 2 arrays to hold alive and available hosts
aHosts=( $(<available.txt))
targets=( $(<active.txt))

info_text "Scanning identified targets"

# Create a counter so I can choose when to change the ip address
count=1

# Loop through each of the targets found
for t in ${targets[@]}; do
  # Loop through the ports we want to scan for
  for p in ${ports[@]}; do
    # Randomise the IP every second time (to avoid 3 consecutive connections
    #   from the same IP address )
    #   This checks to see if count = 3
    if [ $count -eq 3 ]
    then
      # Change the IP and reset the counter
      change_ip $adapter ${aHosts[$RANDOM % ${#aHosts[@]} ] }
      count=1
    else
      # Just add one to the counter
      ((count++))
    fi
    # Scan the host
    host_scan $p $t &

    # Wait for everything to finsh
    wait

  done
done

ok_text "Scan complete, reverting to original IP"
# Revert to original IP address
change_ip $adapter $IP

ok_text "Cleaning up"

# Remove the temp files we made
rm active.txt
rm available.txt

ok_text "--------------------------------"

# get stats after completion
# (Loops through ports and greps for the open ones)
for p in ${ports[@]}; do
  noOfHosts=$(more $fileName-output.txt | grep $p | wc -l)
  ok_text "Hosts that have port $p open : $noOfHosts"
done

# Get the end time
end=`date +%s`

# Show how long the script took to finish
ok_text "Finished, time took:$((end-start))s"
